//
//  machoparse.swift
//  Chimera13
//
//  Created by CoolStar on 3/31/20.
//  Copyright Â© 2020 coolstar. All rights reserved.
//

import Foundation
import MachO.dyld

func parseMacho(path: String, symbol: String) -> UInt32 {
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: path)) else {
        return 0
    }
    
    let hdr = UInt32(littleEndian: data.withUnsafeBytes { $0.load(as: UInt32.self) } )
    let cpu = UInt32(littleEndian: data.withUnsafeBytes { $0.load(fromByteOffset: 4, as: UInt32.self) } )
    let ncmds = UInt32(littleEndian: data.withUnsafeBytes { $0.load(fromByteOffset: 16, as: UInt32.self) } )
    
    guard cpu == 0x100000c else {
        return 0
    }
    
    print(String(format: "Hdr: 0x%x 0x%x %d", hdr, cpu, ncmds))
    
    var symOff = UInt32(0)
    var strOff = UInt32(0)
    var indirectSymOff = UInt32(0)
    var nIndirectSyms = UInt32(0)
    
    var segmentOffset = 32
    for _ in 0..<ncmds {
        let cmd = UInt32(littleEndian: data.withUnsafeBytes( { $0.load(fromByteOffset: segmentOffset, as: UInt32.self) } ))
        let cmdSize = UInt32(littleEndian: data.withUnsafeBytes( { $0.load(fromByteOffset: segmentOffset + 4, as: UInt32.self) } ))
        defer { segmentOffset += Int(cmdSize) }
        
        if cmd == LC_SYMTAB {
            print("Found symtab")
            
            let parsedCmd = data.withUnsafeBytes( { $0.load( fromByteOffset: segmentOffset, as: symtab_command.self) } )
            print(String(format: "\tSyms: 0x%x Strs: 0x%x", parsedCmd.symoff, parsedCmd.stroff))
            
            symOff = parsedCmd.symoff
            strOff = parsedCmd.stroff
        }
        
        if cmd == LC_DYSYMTAB {
            print("Found dysymtab")
            
            let parsedCmd = data.withUnsafeBytes( { $0.load( fromByteOffset: segmentOffset, as: dysymtab_command.self) } )
            print(String(format: "\tIndirect Sym Off: 0x%x %d", parsedCmd.indirectsymoff, parsedCmd.nindirectsyms))
            
            indirectSymOff = parsedCmd.indirectsymoff
            nIndirectSyms = parsedCmd.nindirectsyms
        }
    }
    
    guard symOff != 0,
        strOff != 0,
        indirectSymOff != 0,
        nIndirectSyms != 0 else {
            return 0
    }
    
    segmentOffset = 32
    for _ in 0..<ncmds {
        let cmd = UInt32(littleEndian: data.withUnsafeBytes( { $0.load(fromByteOffset: segmentOffset, as: UInt32.self) } ))
        let cmdSize = UInt32(littleEndian: data.withUnsafeBytes( { $0.load(fromByteOffset: segmentOffset + 4, as: UInt32.self) } ))
        defer { segmentOffset += Int(cmdSize) }
        
        if cmd == LC_SEGMENT_64 {
            var segment = data.withUnsafeBytes( { $0.load(fromByteOffset: segmentOffset, as: segment_command_64.self) } )
            let segNameArr = [Int8](UnsafeBufferPointer(start: &segment.segname.0, count: MemoryLayout.size(ofValue: segment.segname)))
            guard let segNameRaw = String(bytes: segNameArr.map { UInt8($0) }, encoding: .utf8) else {
                continue
            }
            let segName = segNameRaw.components(separatedBy: "\0")[0]
            if segName == "__DATA" || segName == "__DATA_CONST" {
                print("Found data segment")
                var sectionOff = segmentOffset + MemoryLayout.size(ofValue: segment)
                for _ in 0..<segment.nsects {
                    let section = data.withUnsafeBytes( { $0.load(fromByteOffset: sectionOff, as: section_64.self) } )
                    
                    if Int32(section.flags) & SECTION_TYPE == S_LAZY_SYMBOL_POINTERS ||
                        Int32(section.flags) & SECTION_TYPE == S_NON_LAZY_SYMBOL_POINTERS {
                        print("\tFound section")
                        
                        let startIndex = section.reserved1
                        print("\tStart index:",startIndex)
                        
                        var index = UInt32(0)
                        while (index < UInt32(section.size / 8)){
                            defer { index += 1 }
                            
                            let symIndex = startIndex + index
                            let symtabIndex = UInt32(littleEndian: data.withUnsafeBytes( { $0.load(fromByteOffset: Int(indirectSymOff + (symIndex * 4)), as: UInt32.self) } ))
                            
                            guard symtabIndex != INDIRECT_SYMBOL_ABS &&
                                symtabIndex != INDIRECT_SYMBOL_LOCAL &&
                                symtabIndex != (INDIRECT_SYMBOL_LOCAL | UInt32(INDIRECT_SYMBOL_ABS)) else {
                                continue
                            }
                            
                            let symbolOffset = Int(symOff) + Int(symtabIndex) * MemoryLayout<nlist_64>.size
                            let symtab = data.withUnsafeBytes( { $0.load(fromByteOffset: symbolOffset, as: nlist_64.self) } )
                            guard symtab.n_un.n_strx != 0 else {
                                continue
                            }
                            
                            let stringOff = strOff + symtab.n_un.n_strx
                            let dataSlid = data.advanced(by: Int(stringOff))
                            guard let ptr = dataSlid.withUnsafeBytes( {
                                    $0.bindMemory(to: UInt8.self)
                            }).baseAddress else {
                                continue
                            }
                            let str = String(decodingCString: ptr, as: UTF8.self)
                            if str == symbol {
                                print("Found our symbol!",str)
                                let patchOffset = section.offset + (UInt32(index) * 8)
                                return patchOffset
                            }
                        }
                    }
                    sectionOff += MemoryLayout.size(ofValue: section)
                }
            }
        }
    }
    return 0
}
